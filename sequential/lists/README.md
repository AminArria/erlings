# Lists

## Recursion
[Relevant chapter in Learn You Some Erlang](http://learnyousomeerlang.com/recursion)

### Reverse
Recursion can be tricky if you don't have a functional programming
background, for that reason take your time to read and really understand
that concept, a good place to start can be
[Wikipedia for theory](https://en.wikipedia.org/wiki/Recursion_(computer_science)),
and [Learn some erlang](http://learnyousomeerlang.com/recursion) for
practical part.

This exercise consists in creating `reverse/1` which should be
[Tail Recursive](https://stackoverflow.com/questions/33923/what-is-tail-recursion),
and take a list as argument and return another list with every element
int the opposed position. For example if the input is `[1,2,3,4]` the
output should be `[4,3,2,1]`.

[solution](solution/reverse.erl)

### Remove consecutive
Create a function `rmconsecutive/1` that takes a list and returns
another one but without any consecutive repetitions, for example if
the input is `[1,1,1,2,3,4,1,1,1,3]` the output should be `[1,2,3,4,1,3]`.

[solution](solution/rmconsecutive.erl)

### Even Fibonacci Numbers
Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:

` 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...`

By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.

[solution](solution/even_fib_numbers.erl)

### Reduce
Implement `list:foldl/3` and `list:foldl/2` using recursion (see [Erlang foldl reference](http://erlang.org/doc/man/lists.html#foldl-3)).

Example:
``` erlang
list:foldl(fun(X, Y) -> X + Y end, 0, [1, 2, 3, 4]).
%% 10

list:foldl(fun(X, Y) -> X * Y end, [1, 2, 3]).
%% 6

list:foldl(func(X, Y) -> X andalso Y, [true, false, true]).
%% false
```
[solution](solution/reduce.erl)

### Rotate Lists
Create a function `list:rotate/2` that rotates the contents of a
list `n` positions. It should take 2 arguments:

- A list
- A tuple of `{left, N}` or `{right, N}` that indicates the direction
  and the size of the displacement expected.

For example calling `list:rotate([1, 2, 3, 4, 5], {right, 2})` should
return `[3,4,5,1,2]`.

[solution](solution/rotate_list.erl)

### Run-length encoding of a list
Implement the so-called run-length encoding data compression method. Consecutive duplicates of elements are encoded as terms [N,E] where N is the number of duplicates of the element E.

Example:

``` erlang
list:run_length_encode([a,a,a,a,b,c,c,a,a,d,e,e,e,e]).
%%[[4,a],[1,b],[2,c],[2,a],[1,d],[4,e]]
```

[solution](solution/run_length_encoding.erl)

## Higher Order Functions
[Relevant chapter in Learn You Some Erlang](http://learnyousomeerlang.com/higher-order-functions)

### Reduce
Implement `foldl/3` and `foldl/2` using recursion (see [Erlang foldl reference](http://erlang.org/doc/man/lists.html#foldl-3)).

Example:
``` erlang
list:foldl(fun(X, Y) -> X + Y end, 0, [1, 2, 3, 4]).
%% 10

list:foldl(fun(X, Y) -> X * Y end, [1, 2, 3]).
%% 6

list:foldl(func(X, Y) -> X andalso Y, [true, false, true]).
%% false
```
[solution](solution/reduce.erl)

### Any
Write a function `list_any/2` that takes a predicate (a function that returns a boolean value) and a list and returns true if any element of the list satisfies the predicate and false otherwise.

Example:
``` erlang
list:any(fun(X) -> X > 3 end, [4, 2, 0]).
%% true

list:any(fun(X) -> X == 0 end, [1, 2, 3]).
%% false
```

Note: Implement it without using `lists:any`.

[solution](solution/any.erl)
